import argparse
import sys
import cryptography.x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa, padding, ec
from cryptography.hazmat.primitives import hashes, serialization
from datetime import datetime, timezone

def load_certificate(cert_format, cert_file):
    try:
        with open(cert_file, "rb") as f:
            cert_data = f.read()

        if cert_format.upper() == "PEM":
            return cryptography.x509.load_pem_x509_certificate(cert_data, default_backend())
        elif cert_format.upper() == "DER":
            return cryptography.x509.load_der_x509_certificate(cert_data, default_backend())
        else:
            print("Format non support√©. Utilisez DER ou PEM.")
            sys.exit(1)
    except Exception as e:
        print(f"Erreur lors du chargement du certificat : {e}")
        sys.exit(1)

def extract_certificate_info(cert):
    try:
        key_usage_ext = cert.extensions.get_extension_for_class(cryptography.x509.KeyUsage).value
    except cryptography.x509.ExtensionNotFound:
        key_usage_ext = "Non d√©fini"

    info = {
        "Sujet": cert.subject.rfc4514_string(),
        "√âmetteur": cert.issuer.rfc4514_string(),
        "Validit√©": f"{cert.not_valid_before_utc} - {cert.not_valid_after_utc}",
        "Num√©ro de s√©rie": cert.serial_number,
        "Signature Algorithme": cert.signature_algorithm_oid._name,
        "Cl√© publique": cert.public_key().public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        ).decode(),
        "Key Usage": key_usage_ext
    }
    return info

def is_self_signed(cert):
    return cert.issuer == cert.subject

def verify_certificate_signature(cert, issuer_cert):
    try:
        public_key = issuer_cert.public_key()
        signature = cert.signature
        data = cert.tbs_certificate_bytes
        hash_algorithm = cert.signature_hash_algorithm

        if isinstance(public_key, rsa.RSAPublicKey):
            public_key.verify(
                signature,
                data,
                padding.PKCS1v15(),
                hash_algorithm
            )
        elif isinstance(public_key, ec.EllipticCurvePublicKey):
            public_key.verify(
                signature,
                data,
                ec.ECDSA(hash_algorithm)
            )
        else:
            return "Type de cl√© publique non support√©."
        return "La signature du certificat est valide."
    except Exception as e:
        return f"√âchec de la v√©rification de la signature : {e}"

def check_validity_period(cert):
    now = datetime.now(timezone.utc)
    not_before = cert.not_valid_before_utc
    not_after = cert.not_valid_after_utc
    if not_before <= now <= not_after:
        return "Le certificat est actuellement valide (p√©riode OK)."
    else:
        return "Le certificat est expir√© ou non encore valide."

def main():
    parser = argparse.ArgumentParser(description="Validation d‚Äôun certificat X.509 avec signature et p√©riode")
    parser.add_argument("format", choices=["DER", "PEM"], help="Format du certificat")
    parser.add_argument("certfile", help="Fichier du certificat √† analyser")
    parser.add_argument("--issuer", help="Fichier du certificat √©metteur (si non auto-sign√©)", default=None)
    args = parser.parse_args()

    cert = load_certificate(args.format, args.certfile)
    cert_info = extract_certificate_info(cert)

    print("\nüîé Informations extraites du certificat :")
    for key, value in cert_info.items():
        print(f"{key}: {value}")

    # V√©rification de la signature
    if is_self_signed(cert):
        print("\n Certificat auto-sign√© d√©tect√© (racine). V√©rification avec sa propre cl√©...")
        verification_result = verify_certificate_signature(cert, cert)
    elif args.issuer:
        issuer_cert = load_certificate(args.format, args.issuer)
        print(f"\n V√©rification de la signature avec le certificat √©metteur : {args.issuer}")
        verification_result = verify_certificate_signature(cert, issuer_cert)
    else:
        verification_result = " Ce certificat n'est pas auto-sign√©. Sp√©cifiez --issuer pour v√©rifier sa signature."

    print("\n" + verification_result)

    # V√©rification de la p√©riode de validit√©
    validity_result = check_validity_period(cert)
    print("\n" + validity_result)

if __name__ == "__main__":
    main()
