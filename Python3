import argparse
import sys
import os
import hashlib
import datetime
import requests

import cryptography.x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.x509.oid import ExtensionOID, AuthorityInformationAccessOID
from cryptography.x509.ocsp import OCSPRequestBuilder, load_der_ocsp_response
from datetime import UTC
import ecdsa

CRL_CACHE_DIR = "crl_cache"
os.makedirs(CRL_CACHE_DIR, exist_ok=True)

# === Chargement certificat ===
def load_certificate(cert_format, cert_file):
    try:
        with open(cert_file, "rb") as f:
            cert_data = f.read()

        if cert_format.upper() == "PEM":
            return cryptography.x509.load_pem_x509_certificate(cert_data, default_backend())
        elif cert_format.upper() == "DER":
            return cryptography.x509.load_der_x509_certificate(cert_data, default_backend())
        else:
            print("Format non support√©. Utilisez DER ou PEM.")
            sys.exit(1)
    except Exception as e:
        print(f"Erreur lors du chargement du certificat : {e}")
        sys.exit(1)

# === Fonctions de hash ===
def get_hash_function(hash_algorithm):
    if isinstance(hash_algorithm, hashes.SHA256):
        return hashlib.sha256
    elif isinstance(hash_algorithm, hashes.SHA384):
        return hashlib.sha384
    elif isinstance(hash_algorithm, hashes.SHA512):
        return hashlib.sha512
    elif isinstance(hash_algorithm, hashes.SHA1):
        return hashlib.sha1
    else:
        raise ValueError(f"Algorithme de hachage non support√©: {hash_algorithm}")

# === Signature RSA ===
def verify_signature_rsa(public_key, signature, data, hash_algorithm):
    n = public_key.public_numbers().n
    e = public_key.public_numbers().e
    signature_int = int.from_bytes(signature, byteorder='big')
    decrypted_int = pow(signature_int, e, n)
    hash_func = get_hash_function(hash_algorithm)
    data_hash = hash_func(data).digest()
    decrypted_bytes = decrypted_int.to_bytes((n.bit_length() + 7) // 8, byteorder='big')
    return data_hash in decrypted_bytes

# === Signature ECDSA ===
def verify_signature_ecdsa(public_key, signature, data, hash_algorithm):
    try:
        pem = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        ).decode()
        vk = ecdsa.VerifyingKey.from_pem(pem)
        hash_func = get_hash_function(hash_algorithm)
        digest = hash_func(data).digest()
        return vk.verify(signature, digest, hashfunc=hash_func)
    except ecdsa.BadSignatureError:
        return False
    except Exception as e:
        print(f"Erreur lors de la v√©rification de signature ECDSA : {e}")
        return False

# === Cha√Æne de certificats ===
def verify_certificate_chain(certificates):
    for i in range(len(certificates) - 1):
        parent_cert = certificates[i]
        child_cert = certificates[i + 1]

        print(f"\n V√©rification de la correspondance Issuer -> Subject")
        print(f"Issuer attendu : {parent_cert.subject}")
        print(f"Issuer du certificat enfant : {child_cert.issuer}")

        if child_cert.issuer != parent_cert.subject:
            print(" Erreur : Le sujet de l'√©metteur ne correspond pas au certificat parent.")
            return False

        public_key = parent_cert.public_key()
        signature = child_cert.signature
        data = child_cert.tbs_certificate_bytes
        hash_algorithm = child_cert.signature_hash_algorithm

        if isinstance(public_key, cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey):
            if not verify_signature_rsa(public_key, signature, data, hash_algorithm):
                print(" √âchec de la v√©rification de signature RSA.")
                return False
        elif isinstance(public_key, cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey):
            if not verify_signature_ecdsa(public_key, signature, data, hash_algorithm):
                print(" √âchec de la v√©rification de signature ECDSA.")
                return False
        else:
            print(f" Type de cl√© non support√©: {type(public_key)}")
            return False
    return True

# === Basic Constraints & Key Usage ===
def check_basic_constraints(cert):
    try:
        ext = cert.extensions.get_extension_for_oid(ExtensionOID.BASIC_CONSTRAINTS).value
        return ext.ca
    except cryptography.x509.ExtensionNotFound:
        print(f" Avertissement: Extension BasicConstraints non trouv√©e")
        return False

def check_key_usage(cert, is_ca):
    try:
        key_usage = cert.extensions.get_extension_for_oid(ExtensionOID.KEY_USAGE).value
        if is_ca and not key_usage.key_cert_sign:
            print(" Erreur: Certificat CA sans l'autorisation key_cert_sign")
            return False
        if not is_ca and key_usage.key_cert_sign:
            print(" Avertissement: Certificat non-CA avec l'autorisation key_cert_sign")
        return True
    except cryptography.x509.ExtensionNotFound:
        print(f" Avertissement: Extension KeyUsage non trouv√©e")
        return False

# === T√©l√©chargement et cache CRL ===
def download_crl(crl_url):
    filename = os.path.join(CRL_CACHE_DIR, hashlib.sha256(crl_url.encode()).hexdigest() + ".crl")
    if os.path.exists(filename):
        with open(filename, 'rb') as f:
            crl_data = f.read()
            try:
                crl = cryptography.x509.load_der_x509_crl(crl_data, default_backend())
            except ValueError:
                crl = cryptography.x509.load_pem_x509_crl(crl_data, default_backend())
            if crl.next_update_utc > datetime.datetime.now(UTC):
                print(f"üìÑ CRL en cache utilis√©e : {crl_url}")
                return crl
            else:
                print(f" CRL expir√©e, nouveau t√©l√©chargement : {crl_url}")

    print(f" T√©l√©chargement CRL : {crl_url}")
    response = requests.get(crl_url, timeout=10)
    response.raise_for_status()
    crl_data = response.content
    try:
        crl = cryptography.x509.load_der_x509_crl(crl_data, default_backend())
    except ValueError:
        crl = cryptography.x509.load_pem_x509_crl(crl_data, default_backend())
    with open(filename, 'wb') as f:
        f.write(crl_data)
    return crl

# === V√©rification via CRL ===
def check_revocation_crl(cert, issuer_cert):
    try:
        crl_ext = cert.extensions.get_extension_for_oid(ExtensionOID.CRL_DISTRIBUTION_POINTS)
        for dp in crl_ext.value:
            for uri in dp.full_name:
                if uri.value.startswith("http"):
                    crl = download_crl(uri.value)
                    if not crl.is_signature_valid(issuer_cert.public_key()):
                        print("Signature de la CRL invalide.")
                        return False
                    for revoked_cert in crl:
                        if revoked_cert.serial_number == cert.serial_number:
                            print("Certificat r√©voqu√© selon la CRL.")
                            return False
        print("Certificat non r√©voqu√© selon la CRL.")
        return True
    except Exception as e:
        print(f"Erreur v√©rification CRL : {e}")
        return True

# === V√©rification OCSP ===
def check_revocation_ocsp(cert, issuer_cert):
    try:
        aia_ext = cert.extensions.get_extension_for_oid(ExtensionOID.AUTHORITY_INFORMATION_ACCESS)
        ocsp_urls = [
            desc.access_location.value
            for desc in aia_ext.value
            if desc.access_method == AuthorityInformationAccessOID.OCSP
        ]
        if not ocsp_urls:
            print("Aucun point OCSP trouv√©.")
            return True

        ocsp_url = ocsp_urls[0]
        print(f"V√©rification OCSP via {ocsp_url}")
        builder = OCSPRequestBuilder().add_certificate(cert, issuer_cert, hashes.SHA1())
        req = builder.build()
        headers = {'Content-Type': 'application/ocsp-request'}
        response = requests.post(ocsp_url, data=req.public_bytes(serialization.Encoding.DER), headers=headers, timeout=10)
        ocsp_response = load_der_ocsp_response(response.content)

        if ocsp_response.response_status.name != "SUCCESSFUL":
            print(f"OCSP √©chou√© : {ocsp_response.response_status}")
            return False

        status = ocsp_response.certificate_status
        if status.name == "good":
            print("Certificat valide selon OCSP.")
            return True
        elif status.name == "revoked":
            print("Certificat r√©voqu√© selon OCSP.")
            return False
        elif status.name == "unknown":
            print("Certificat inconnu dans l‚ÄôOCSP (statut 'unknown'). On continue par pr√©caution.")
            return True
        else:
            print(f"Statut OCSP inattendu : {status.name}")
            return True
    except Exception as e:
        print(f"Erreur OCSP : {e}")
        return True

# === MAIN ===
def main():
    parser = argparse.ArgumentParser(description="Validation d'une cha√Æne de certificats X.509 avec CRL et OCSP")
    parser.add_argument("format", choices=["DER", "PEM"], help="Format des certificats")
    parser.add_argument("certfiles", nargs='+', help="Fichiers de certificats (de la racine √† la feuille)")
    args = parser.parse_args()

    certificates = [load_certificate(args.format, file) for file in args.certfiles]

    if not verify_certificate_chain(certificates):
        print("La cha√Æne de certificats n'est pas valide.")
        sys.exit(1)

    for i, cert in enumerate(certificates):
        is_ca = check_basic_constraints(cert)
        if not check_key_usage(cert, is_ca):
            print(f"Le certificat {i} a une extension KeyUsage incorrecte.")
            sys.exit(1)

    for i in range(1, len(certificates)):
        cert = certificates[i]
        issuer = certificates[i - 1]

        print(f"\n V√©rification r√©vocation pour le certificat {i}...")
        if not check_revocation_crl(cert, issuer):
            print("R√©vocation CRL d√©tect√©e.")
            sys.exit(1)
        if not check_revocation_ocsp(cert, issuer):
            print("R√©vocation OCSP d√©tect√©e.")
            sys.exit(1)

    print("\n Tous les certificats sont valides et non r√©voqu√©s !")

if __name__ == "__main__":
    main()
